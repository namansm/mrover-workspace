void MRoverArm::target_orientation_callback(string channel, TargetOrientation msg){
    cout << "target orientation callback";
    TargetOrientation point_msg = msg;
    enable_execute = false;
    //this statement replaced logger
    cout << "Got a target point." << endl;

    cout << "alpha beta gamma" << endl << endl;
    cout << point_msg.alpha << " , " << point_msg.beta << " , " << point_msg.gamma << endl << endl;
    bool use_orientation = point_msg.use_orientation;
    cout << use_orientation << endl; 

    double point[6] = {point_msg.x, point_msg.y, point_msg.z, point_msg.alpha, point_msg.beta, point_msg.gamma};

    bool success = false;
    pair<vector<double>, bool> ik_solution = solver.IK(point, false, use_orientation);
    
    for(int i = 0; i<5; ++i){
        if(ik_solution.second){
            cout << "Solved IK" << endl;
            break;
        }
        cout << "Attempting new IK solution..." << endl << i << endl;
        ik_solution = solver.IK(point, true, use_orientation);
    }
    if(!ik_solution.second){
        cout << "NO IK SOLUTION FOUND, please try a different configuration." << endl;
        return;
    }

    publish_transforms(state);
    //Is it curly brackets for a vector?
    Vector6d goal(joint_angles["joint_a"], joint_angles["joint_b"], joint_angles["joint_c"], joint_angles["joint_d"], joint_angles["joint_e"],joint_angles["joint_f"]);
    plan_path(goal);
}

void MRoverArm::target_angles_callback(string channel, TargetAngles msg){
    enable_execute = false;
    TargetAngles target_angles = msg;

    Vector6d goal(target_angles.joint_a,
                target_angles.joint_b,
                target_angles.joint_c,
                target_angles.joint_d,
                target_angles.joint_e,
                target_angles.joint_f);
    for(int i = 0; i<6; i++){
        cout << goal[i] << "\t";
    }
    cout << endl;
    //why is the color different here for plan_path
    plan_path(goal); 
}

void MRoverArm::plan_path(Vector6d goal){
    cout << "goal" << endl;
    for(int i = 0; i<goal.size(); i++){
        cout << goal[i] << "\t";
    }
    cout << endl << "start" << endl;
    //What is state.angles, is it vector6d?
    map<string, double> joint_angles = state.get_joint_angles();
    for(int i = 0; i<state.angles.size(); i++){
        cout << state.angles[i] << "\t";
    }
    cout << endl;   

    //idk this data type
    vector<tk::spline> path_spline = motion_planner.rrt_connect(goal);
    if(!path_spline.empty()){
        spline_t = 0;
        cout << "planned path" << endl;
    }
    else{
        cout << "No path found" << endl;
    }
}

void MRoverArm::motion_execute_callback(string channel, MotionExecute msg){
    MotionExecute motion_execute_msg = msg;

    bool preview = motion_execute_msg.preview;
    if(preview){
        enable_execute = false;
        //what is preview
        motion_execute_msg.preview();
    }
    else{
        enable_execute = true;
    }
}

void MRoverArm::simulation_mode_callback(string channel, SimulationMode msg){
    SimulationMode simulation_mode_msg = msg;

    bool sim_mode = simulation_mode_msg.sim_mode;
    publish_transforms(state);
}

void MRoverArm::cartesian_control_callback(string channel, IkArmControl msg){
    if(enable_execute){
        return;
    }

    IkArmControl cart_msg = msg;
    double delta[3] = {cart_msg.deltaX, cart_msg.deltaY, cart_msg.deltaZ};
    //idk if this line is right down here
    pair<vector<double> joint_angles, bool is_safe> = solver.IK_delta(delta, 3);
    
    if(is_safe){
        ArmPosition arm_position = ArmPosition();
        arm_position.joint_a = joint_angles["joint_a"];
        arm_position.joint_b = joint_angles["joint_b"];
        arm_position.joint_c = joint_angles["joint_c"];
        arm_position.joint_d = joint_angles["joint_d"];
        arm_position.joint_e = joint_angles["joint_e"];
        arm_position.joint_f = joint_angles["joint_f"];
        //what is set_angles
        state.set_angles(arm_position);
        solver.FK(state);   
        publish_transforms(state);
        //again, running into the issue of encode(), should we even have it there
        if(sim_mode){
            cout << "Printing sim_mode" << endl;
            lcm_.publish("/arm_position", arm_position.encode());
        }
        else{
            cout << "Printing" << endl;
            lcm_.publish("/ik_ra_control", arm_position.encode());
        }
    }


}
